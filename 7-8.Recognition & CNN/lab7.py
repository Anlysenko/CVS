# -*- coding: utf-8 -*-
"""Lab7.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1If8_zTZ_3Cl3PR_6vPdsZHGsEGODDt-B
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')
# %cd /content/drive/'My Drive'/CV/Lab7/
!ls

import cv2
import numpy as np
import matplotlib.pyplot as plt

import tensorflow.compat.v2 as tf
import tensorflow_datasets as tfds

tfds.disable_progress_bar()
tf.enable_v2_behavior()

"""##Корреляционное сопоставление"""

pic1_orig = cv2.imread('cameraman.tif',0)
image1_np=np.array(pic1_orig, dtype='uint8')
template = cv2.imread('template.jpg',0)
w, h = template.shape[::-1]

noisy_img = np.array(image1_np + (20 - np.random.normal(0, 30, image1_np.shape)), dtype='uint8')
noisy_img_clipped = np.clip(noisy_img, 0, 255)

res = cv2.matchTemplate(noisy_img_clipped, template, cv2.TM_CCORR_NORMED)

_,_,_,top_left = cv2.minMaxLoc(res)
bottom_right = (top_left[0] + w, top_left[1] + h)
cv2.rectangle(image1_np,top_left, bottom_right, 255, 2)

plt.figure(figsize = (20,20))
plt.subplot(2,2,1), plt.xticks([]), plt.yticks([]), plt.imshow(pic1_orig, cmap='gray')
plt.subplot(2,2,2), plt.xticks([]), plt.yticks([]), plt.imshow(noisy_img_clipped, cmap='gray')
plt.subplot(2,2,3), plt.xticks([]), plt.yticks([]), plt.imshow(res, cmap='gray')
plt.subplot(2,2,4), plt.xticks([]), plt.yticks([]), plt.imshow(image1_np, cmap='gray')

"""#CNN"""

#Downloading the Mnist Data
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()
image_index = 22356
plt.imshow(x_train[image_index], cmap='gray')
print('\n ----- Value = ' + str(y_train[image_index]))

# Reshaping the array to 4-dims so that it can work with the Keras API
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)
input_shape = (28, 28, 1)
# Making sure that the values are float so that we can get decimal points after division
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
# Normalizing by dividing it to the max value.
x_train /= 255
x_test /= 255
print('\n ----- x_train shape:', x_train.shape)
print('\n ----- Number of images in x_train = ', x_train.shape[0])
print('\n ----- Number of images in x_test  = ', x_test.shape[0])

# Creating a Sequential Model and adding the layers
model = tf.keras.models.Sequential([
  tf.keras.layers.Conv2D(20, (5, 5), input_shape = (28,28,1), strides=1),
  tf.keras.layers.MaxPooling2D(pool_size=(2, 2), strides=2),
  tf.keras.layers.Conv2D(50, (5, 5), strides=1),
  tf.keras.layers.MaxPooling2D((2, 2), strides=2),
  tf.keras.layers.Conv2D(500, (4, 4), strides=1),
  tf.keras.layers.ReLU(),
  tf.keras.layers.Conv2D(10, (1, 1), strides=1),
  tf.keras.layers.Flatten(),
  tf.keras.layers.Softmax()
])
model.summary()

#Compiling and Fitting the Model
model.compile(
    loss='sparse_categorical_crossentropy',
    optimizer=tf.keras.optimizers.Adam(0.001),
    metrics=['accuracy'],
)
model.fit(
    x=x_train,
    y=y_train,
    epochs=6,
    validation_data=(x_test, y_test)
)

image_index = 3333
plt.imshow(x_test[image_index].reshape(28, 28),cmap='gray')
pred = model.predict(x_test[image_index].reshape(1, 28, 28, 1))
print('\n ----- Predicted number = ', pred.argmax())